#!/usr/bin/env python3
# Copyright (c) 2022 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import os
from pathlib import Path
import subprocess
from typing import List, Tuple

BASE_PATH = Path(__file__).parents[1]
REQUIREMENTS_IN = BASE_PATH.joinpath("requirements.in")
REQUIREMENTS_TXT = BASE_PATH.joinpath("requirements.txt")

MANUAL_PACKAGES = [
    # Packages which are required for GAE, but are not (yet) available in cipd
    # can be added here. Make sure those packages can be trusted since they
    # circumvent cipd's auditing process.
    #
    # ('google-cloud-logging', '3.0.0'),
]


def rm_prefix(value, prefix):
  if value.startswith(prefix):
    return value[len(prefix):]
  return value


def rm_suffix(value, suffix):
  if value.endswith(suffix):
    return value[:-len(suffix)]
  return value


class VPythonParser:
  # Adapted from https://chromium.googlesource.com/infra/infra/+/a0d5d3afba376 \
  # 30322e73035640f74669ce94ea5/go/src/infra/tools/vpython/utils/wheels.py#144

  def __init__(self, vpython_path):
    self.vpython_path = vpython_path

  def wheel_starts(self, line):
    return line.startswith('wheel: <')

  def in_wheel(self, line):
    return line.startswith('  name:') or line.startswith('  version:')

  def wheel_ends(self, line):
    return line.startswith('>')

  def clean_name(self, cipd_name):
    """Extract package name from cipd identifier.

    Examples:

      infra/python/wheels/werkzeug-py3 → werkzeug
      infra/python/wheels/markupsafe/${vpython_platform} → markupsafe
      infra/python/wheels/google-api-core-py2_py3 → google-api-core
    """
    name = rm_prefix(cipd_name, 'infra/python/wheels/')
    name = name.rsplit('/', 1)[0]  # Remove trailing `/${vpython_platform}`
    name = rm_suffix(name, '-py2_py3')
    name = rm_suffix(name, '-py3')
    name = name.replace('_', '-')
    return name

  def parse(self) -> List[Tuple[str, str]]:
    """Read the .vpython3 file and create a list of pinned dependencies."""
    with open(self.vpython_path) as wheels_file:
      results = []
      for line in wheels_file:
        if self.wheel_starts(line):
          current_result = {}
        if self.in_wheel(line):
          parsed_line = line.split()
          key = parsed_line[0].rstrip(':')  # `name:` or `version:`
          value = parsed_line[1].strip('"')
          current_result[key] = value
        if self.wheel_ends(line):
          name = self.clean_name(current_result['name'])
          version = current_result['version'].lstrip('version:')
          results.append((name, version))

      return results


def retrieve_deps() -> List[Tuple[str, str]]:
  vpython_deps = BASE_PATH.joinpath('.vpython3')
  return MANUAL_PACKAGES + VPythonParser(vpython_deps).parse()


def generate_requirements_in(deps: List[Tuple[str, str]]):
  seen = set()

  # Only add first appearance of each package
  cleaned_deps = list()
  for name, version in deps:
    if name in seen:
      continue
    seen.add(name)
    cleaned_deps.append((name, version))

  # Write dependencies to requirements.in file
  content = "\n".join(f'{name}=={version}' for name, version in cleaned_deps)
  with open(REQUIREMENTS_IN, 'w') as requirements_in:
    requirements_in.write(content + '\n')


def compile_requirements_txt():
  cmd = [
      'pip-compile',
      '--allow-unsafe',
      '--generate-hashes',
      '--no-header',
      '--no-annotate',
      '--strip-extras',
      '--output-file',
      REQUIREMENTS_TXT,
      REQUIREMENTS_IN,
  ]
  subprocess.run(cmd, capture_output=True, check=True)


def add_auto_generation_disclaimer():
  with open(REQUIREMENTS_TXT, 'r+') as txt:
    message = ('# This file is autogenerated. Add packages to .vpython3.\n' +
               '# \n' + '# To update, run:\n' + '# \n' +
               '#   python3 ./tools/generate_requirements_txt.py\n' + '# \n' +
               txt.read())

    # Write new content; we have already read the file, so we jump to the start
    # again
    txt.seek(0, 0)
    txt.write(message)


def validate_recursive_dependencies(defined_deps: List[Tuple[str, str]]):
  """Assert that all recursive dependencies are defined in .vpython3 too."""
  generated_deps = []
  with open(REQUIREMENTS_TXT) as f:
    for line in filter(lambda line: '==' in line, f.readlines()):
      name, version = line.split('==')
      version = version[:-3]
      generated_deps.append((name, version))

  defined_deps_by_name = dict(defined_deps)

  errors = []
  for name, version in generated_deps:
    if name not in defined_deps_by_name:
      errors.append(
          f'{name}=={version} found in requirements.txt, but not in .vpython3')
      continue
    if defined_deps_by_name[name] != version:
      errors.append(
          f'{name}=={version} found in requirements.txt, but .vpython3 defines '
          f'version {defined_deps_by_name[name]}')

  if len(errors) > 0:
    # Add error formatting and provide hints to fix the issues:
    errors_msg = '\n'.join(['  · ' + error for error in errors])
    raise Exception(
        'Generated requirements.txt differs from definitions in .vpython3:\n\n'
        + errors_msg + '\n\n' +
        'Fix the .vpython3 definitions and re-run this command.')


def cleanup():
  os.remove(REQUIREMENTS_IN)


if __name__ == '__main__':
  deps = retrieve_deps()

  generate_requirements_in(deps)
  compile_requirements_txt()
  validate_recursive_dependencies(deps)
  add_auto_generation_disclaimer()
  cleanup()
